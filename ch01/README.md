> 인프런의 강민철님의 [모두의 깃 깃허브](https://www.inflearn.com/course/%EB%AA%A8%EB%91%90%EC%9D%98-%EA%B9%83-%EA%B9%83%ED%97%88%EB%B8%8C/dashboard) 강의를 참조하였습니다.

## 로컬 저장소 만들기

먼저 이론적인 학습하기 전에 이전에 설치한 소스트리로 로컬저장소를 세팅해준 후 이론 학습을 하기로 한다. 여기서 로컬 저장소란 깃으로 관리되는 버전들이 모여있는 저장소를 의미하며 목적지 경로란 해당경로를 깃으로 관리한다고 정의한 것이다.

### 소스트리 로컬 저장소 생성

먼저 소스트리를 켜고 새로만들기라는 탭에 로컬저장소 생성이라는 버튼을 클릭한다.

![](https://velog.velcdn.com/images/bini/post/da194238-d79f-4918-8787-fad98ebd6f3f/image.png)

여기서 임의로 만든 폴더를 목적지 경로로 설정 후 생성하기 버튼을 클릭하면 아래와 같이 생성된다.

![](https://velog.velcdn.com/images/bini/post/ed8cdd46-f588-4fb1-845c-e157f6e34a17/image.png)

그리고 해당 디렉터리를 보면 .git이라는 파일이 생긴것을 볼 수 있다.

![](https://velog.velcdn.com/images/bini/post/9615d861-a796-49cf-9016-7bddf4a144c3/image.png)

그리고 소스트리의 생성된 로컬저장소를 클릭하면 다음과 같은 화면이 열린다.

![](https://velog.velcdn.com/images/bini/post/bb363945-ddff-4a24-b4bb-30707cd2c237/image.png)

이 화면에서 해당 목적지 경로의 버전 히스트로가 저장되고 관리된다.

### 정리

즉 특정 디렉터리를 목적지 경로로 로컬저장소로 만들면 해당 목적지 경로 안에 .git이라는 숨김폴더가 생긴다.

## 버전관리의 큰 그림

깃이 관리하는 공간은 총 3개의 공간이 존재한다.

- 작업 디렉터리(working tree) : 버전 관리의 대상이 위치하는 공간 (.git이 있는 디렉터리)
- 스테이지: 다음 버전이 될 후보가 올라가는 공간 (스테이지를 인덱스라고도 불린다.)
- 저장소: 버전이 만들어지고 관리되는 공간

여기서 작업 디렉터리는 사용자 눈에 보이는 공간이지만 스테이지와 저장소는 깃이 관리하는 가상의 공간 즉, 눈에 보이지 않는 디렉터리이다.

### 하나의 버전이 만들어지는 과정

우리는 하나의 버전을 만드는 과정을 알아 볼 것이다. 먼저 작업 디렉터리에 여러 파일들이 존재하고, 엄청난 소스코드가 수정되었다고 가정하다. 이런 수많은 변경사항 중에 버전으로 만들고 싶은 변경사항을 스테이지에 올리는 작업이 필요하다. 이것을 스테이지에 add 한다라고 부른다. 버전관리를 하고 싶은 변경사항을 스테이지에 올렸으면 이 파일들을 저장소에 올리는 과정이 필요한데 이것을 저장소로 커밋한다고 한다.

내용을 요약하면 아래와 같다.

- 작업 디렉터리 내에서 변경사항 생성
- 스테이지로 add
- 저장소로 commit

## 버전만들기

실세 이론으로 배운 것을 실습해보자. 먼저 소스트리의 로컬 저장소를 더블클릭해보자.

![](https://velog.velcdn.com/images/bini/post/2e322533-db9a-4fd3-8322-8e459fd9793a/image.png)

여기서 이제 작업 디렉터리 공간에 새로운 파일 (a.txt)를 만들어 보자. 만들면 소스트리 화면이 다음과 같이 변경된다.

![](https://velog.velcdn.com/images/bini/post/f88a0d9a-737e-496e-a9c6-3098279a33c6/image.png)

이런 화면에서 새로운 파일을 스테이지에 올리는 작업을 해보자. 위에 스테이지 올리기 버튼을 클릭하면 다음과 같이 변한다.

![](https://velog.velcdn.com/images/bini/post/e5e72595-55ee-4412-8bdd-d70db771492f/image.png)

다음과 같은 화면에서 이제 커밋메세지를 작성 후 커밋을 누른다. 여기서 커밋 메세지란 스테이지에 올라와 있는 버전의 후보들을 커밋을 할 때 이 변경사항이 어떤 변경이 일어났고 어떤 버전인지 간단한 설명을 작성하는 것을 말한다. 커밋메세지에는 제목과 본문으로 이루어져 있으며 본문은 여러줄이 될 수 있다. 커밋 메세지는 옵셥이지만 왠만해서는 자세히 적자.

커밋 메세지 작성 후, 커밋을 누르고 히스토리 탭을 보면 아래와 같이 보인다.

![](https://velog.velcdn.com/images/bini/post/b23d4663-2751-4b33-b7be-40417a949df6/image.png)

이런식으로 여러 파일을 작성 후 위의 과정처럼 진행을 하면 버전이 생성되는 것을 볼 수 있다.

## 커밋 해시, 태그

커밋 해시란, 커밋한 버전 하나하나를 특정 지을 수 있는 정보를 커밋 해시라고 한다. 일종의 학교의 학번 혹은 회사의 사번과 같다. 그럼 커밋 태그는 무엇일까? 커밋 태그란 특정 커밋을 좀 더 가독성 있게 표현할 수 있는 것을 커밋 태그라고 한다. 일종의 특정 커밋의 꼬리표라고 한다. 그러면 지금 커밋 해시와 설명했던 것과 비슷한데 왜 커밋태그를 사용할까? 계속 커밋을 하다가 마침내 사용자에게 선보일 마지막 커밋이 만들어졌고, 마지막 커밋은 유의미한 버전이기에 이것을 가독성 좋게 꼬리표를 붙이는 작업이 필요하다. 예를들어, v1.0.0이라고 한다. 즉, 유의미한 분기점에 붙이는 정보라고 말한다.

아래는 소스트리로 커밋태그를 붙이는 작업을 보여준다.

![](https://velog.velcdn.com/images/bini/post/fa841ef7-5854-47f9-9a65-fb7d4de4272b/image.png)

![](https://velog.velcdn.com/images/bini/post/d3f060f5-6a8e-4a53-b933-27b342b6dc0b/image.png)
